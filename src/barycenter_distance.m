clc; clear;

filename = "../data/GenreClassData_30s.txt";
classes_to_plot = [1, 2, 3, 6];
classes_to_name_map = containers.Map(classes_to_plot, {'Pop', 'Metal', 'Disco', 'Classical'});
features = {'spectral_rolloff_mean', 'mfcc_1_mean', 'spectral_centroid_mean', 'tempo'};
all_features = {'zero_cross_rate_mean', 'zero_cross_rate_std', ...
    'rmse_mean', 'rmse_var', 'spectral_centroid_var', ...
    'spectral_bandwidth_mean', 'spectral_bandwidth_var', ...
    'spectral_rolloff_var', 'spectral_contrast_mean', 'spectral_contrast_var', ...
    'spectral_flatness_mean', 'spectral_flatness_var', 'chroma_stft_1_mean', ...
    'chroma_stft_2_mean', 'chroma_stft_3_mean', 'chroma_stft_4_mean', ...
    'chroma_stft_5_mean', 'chroma_stft_6_mean', 'chroma_stft_7_mean', ...
    'chroma_stft_8_mean', 'chroma_stft_9_mean', 'chroma_stft_10_mean', ...
    'chroma_stft_11_mean', 'chroma_stft_12_mean', 'chroma_stft_1_std', ...
    'chroma_stft_2_std', 'chroma_stft_3_std', 'chroma_stft_4_std', ...
    'chroma_stft_5_std', 'chroma_stft_6_std', 'chroma_stft_7_std', ...
    'chroma_stft_8_std', 'chroma_stft_9_std', 'chroma_stft_10_std', ...
    'chroma_stft_11_std', 'chroma_stft_12_std', ...
    'mfcc_2_mean', 'mfcc_3_mean', 'mfcc_4_mean', 'mfcc_5_mean', ...
    'mfcc_6_mean', 'mfcc_7_mean', 'mfcc_8_mean', 'mfcc_9_mean', ...
    'mfcc_10_mean', 'mfcc_11_mean', 'mfcc_12_mean', 'mfcc_1_std', ...
    'mfcc_2_std', 'mfcc_3_std', 'mfcc_4_std', 'mfcc_5_std', ...
    'mfcc_6_std', 'mfcc_7_std', 'mfcc_8_std', 'mfcc_9_std', ...
    'mfcc_10_std', 'mfcc_11_std', 'mfcc_12_std', 'GenreID'};

complete_features = {'zero_cross_rate_mean', 'zero_cross_rate_std', ...
    'rmse_mean', 'rmse_var', 'spectral_centroid_mean', 'spectral_centroid_var', ...
    'spectral_bandwidth_mean', 'spectral_bandwidth_var', 'spectral_rolloff_mean', ...
    'spectral_rolloff_var', 'spectral_contrast_mean', 'spectral_contrast_var', ...
    'spectral_flatness_mean', 'spectral_flatness_var', 'chroma_stft_1_mean', ...
    'chroma_stft_2_mean', 'chroma_stft_3_mean', 'chroma_stft_4_mean', ...
    'chroma_stft_5_mean', 'chroma_stft_6_mean', 'chroma_stft_7_mean', ...
    'chroma_stft_8_mean', 'chroma_stft_9_mean', 'chroma_stft_10_mean', ...
    'chroma_stft_11_mean', 'chroma_stft_12_mean', 'chroma_stft_1_std', ...
    'chroma_stft_2_std', 'chroma_stft_3_std', 'chroma_stft_4_std', ...
    'chroma_stft_5_std', 'chroma_stft_6_std', 'chroma_stft_7_std', ...
    'chroma_stft_8_std', 'chroma_stft_9_std', 'chroma_stft_10_std', ...
    'chroma_stft_11_std', 'chroma_stft_12_std', 'tempo', 'mfcc_1_mean', ...
    'mfcc_2_mean', 'mfcc_3_mean', 'mfcc_4_mean', 'mfcc_5_mean', ...
    'mfcc_6_mean', 'mfcc_7_mean', 'mfcc_8_mean', 'mfcc_9_mean', ...
    'mfcc_10_mean', 'mfcc_11_mean', 'mfcc_12_mean', 'mfcc_1_std', ...
    'mfcc_2_std', 'mfcc_3_std', 'mfcc_4_std', 'mfcc_5_std', ...
    'mfcc_6_std', 'mfcc_7_std', 'mfcc_8_std', 'mfcc_9_std', ...
    'mfcc_10_std', 'mfcc_11_std', 'mfcc_12_std', 'GenreID'};

% Read the data
data = readtable(filename, 'Delimiter', '\t');

best_features = [];
for i = 1:length(features)
    % Remove the ith feature from the list
    feature = features{i};
    removed_feature = features(i);
    remaining_features = features;
    remaining_features(i) = [];

    best_feature = [];
    for j = 1:length(all_features)
        % Select the feature to add
        feature_to_add = all_features{j};
        % Add the feature to remaining_features
        remaining_features = [remaining_features, feature_to_add];

        % Compute the barycenters of the classes over these features
        barycenters = zeros(length(classes_to_plot), length(remaining_features));
        for k = 1:length(classes_to_plot)
            classA = classes_to_plot(k);
            class_data = data(data.GenreID == classA, :);
            barycenters(k, :) = mean(class_data{:, remaining_features}, 1);
        end

        % Each barycenter is a point in the feature space. Calculate the distance between the barycenters
        % Compute the pairwise distances between barycenters
        distances = pdist(barycenters, 'euclidean');

        % Select the feature that allows the best separation of the classes
        % The best feature is the one that maximizes the minimum distance between barycenters
        min_distance = min(distances);
        if isempty(best_feature) || min_distance > best_feature{1}
            best_feature = [min_distance, feature_to_add, removed_feature];
        end

        % Remove the feature from the remaining_features list
        remaining_features(strcmp(remaining_features, feature_to_add)) = [];
    end

    % Add the best feature to the list
    best_features = [best_features; best_feature];
end

disp(best_features)